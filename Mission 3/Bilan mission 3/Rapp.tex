\documentclass[11pt]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[french]{babel}
\usepackage{amsmath}
\usepackage[bookmarks={true},bookmarksopen={true}]{hyperref}
\usepackage{graphicx}
\usepackage[a4paper]{geometry}
\usepackage{listings}
	\lstset{frame=tb,
		language=Java,
 		aboveskip=3mm,
  		belowskip=3mm,
  		showstringspaces=false,
  		columns=flexible,
  		basicstyle={\small\ttfamily},
  		numbers=none,
 		numberstyle=\tiny\color{gray},
  		keywordstyle=\color{blue},
  		commentstyle=\color{dkgreen},
  		stringstyle=\color{mauve},
  		breaklines=true,
  		breakatwhitespace=true
  		tabsize=3
	}
\pagestyle{plain}
\setlength{\parindent}{5mm}
\usepackage{amsmath}
\usepackage{color}
\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}



\title{\textbf{Projet LSINF1121 -  Algorithmique et structures de données\\ - \\ Bilan Mission 3} \\ {\large Groupe 26}}
\author{Laurian \bsc{Detiffe} \\(6380-12-00)\and Sundeep \bsc{Dhillon} \\(6401-11-00)\and Alexis \bsc{Macq} \\ (5910-12-00) \and Xavier \bsc{Pérignon} \\ (8025-11-00)\and Thibaut \bsc{Piquard}\\(4634-13-00)\and Thomas \bsc{Wyckmans} \\ (3601-12-00)}
\date{date}
\date{\vspace*{25mm}
\includegraphics[scale=0.75]{logo.jpg}\\
		\vspace*{30mm}
		\begin{center}
		Année académique 2015-2016 \\	
		\end{center}}

\begin{document}
\thispagestyle{empty}

\maketitle
\thispagestyle{empty}
%\tableofcontents
%\setcounter{tocdepth}{3}
%\setcounter{page}{1}
%\newpage

\section*{Questions et réponses}
\begin{enumerate}
\item Vrai ou Faux (BST s’entend ici comme l’implémentation du livre Algorithms-4)
\begin{enumerate}
\item Etant donné un parcours infixe d’un BST contenant N clefs distinctes. Est-il
possible de reconstruire la forme du BST sur base du résultat du parcourt ?\\

{\color{dkgreen}FAUX}. Parce qu'on ne sait pas si l'arbre est équilibré ou non.

\item Dans le meilleur de cas, le nombre de comparaisons entre clefs pour une recherche
binaire d’une clef particulière dans un tableau trié de N clefs distinctes
est $\sim$ lgN. \\

<<<<<<< HEAD
<<<<<<< HEAD
{\color{dkgreen}FAUX}. Ca peut être direct et en moyenne ce sera du log(n).

=======
>>>>>>> origin/master
=======
>>>>>>> origin/master
\item Etant donné un arbre ordonné de N clefs distinctes et une clef x, est-il possible
de trouver la plus petite clef strictement plus grande que x en temps
logarithmique dans le pire cas ? \\

<<<<<<< HEAD
<<<<<<< HEAD
{\color{dkgreen}FAUX.}

=======
>>>>>>> origin/master
=======
>>>>>>> origin/master
\item La hauteur attendue (au sens statistique) d’un BST résultant de l’insertion de
N clefs distinctes dans un ordre aléatoire dans un arbre initialement vide est
logarithmique. \\

<<<<<<< HEAD
<<<<<<< HEAD
{\color{dkgreen}FAUX.} Au sens statistique, on considère que c'est toujours en log, alors c'est vrai mais sinon, c'est faux !

=======
>>>>>>> origin/master
=======
>>>>>>> origin/master
\item Soit x un noeud dans un BST. Le successeur de x (le noeud contenant la clef
suivante dans l’ordre croissant) est le noeud le plus à gauche dans l’arbre de
droite de x.\\

<<<<<<< HEAD
<<<<<<< HEAD
{\color{dkgreen}FAUX.} Dans le cas d'une feuille, c'est faux ! Attention au piège... 
\end{enumerate}

\item Vrai ou Faux (Les 2-3/red-black BST sont ceux du livre Algorithms-4 qui diffère de l'implémentation classique qui correspond à un arbre 2/4).
\begin{enumerate}
\item La hauteur maximum d'un 2-3 tree avec N clefs est $\sim log_3$N.\\

{\color{dkgreen}FAUX.}
=======
\end{enumerate}
=======
\end{enumerate}
>>>>>>> origin/master
\item Vrai ou Faux (Les 2-3/red-black BST sont ceux du livre Algorithms-4).
\begin{enumerate}
\item La hauteur maximum d'un 2-3 tree avec N clefs est $\sim log_3$N.\\

<<<<<<< HEAD
>>>>>>> origin/master
=======
>>>>>>> origin/master

\item L'insertion de N clefs dans l'ordre croissant dans un red-black BST initialement
vide résulte en un nombre de changement de couleur d'au plus N.\\

{\color{dkgreen}VRAI.}

\item Un red-black BST obtenu après insertion de N > 1 clefs dans un arbre initialement
vide possède au moins un lien rouge.\\

{\color{dkgreen}FAUX.}


\item Dans un red-black BST de N noeuds, la hauteur noire (i.e. le nombre de liens
noirs de chaque chemin depuis la racine vers un lien null) est maximum lgN.\\

{\color{dkgreen}VRAI.}

\item Un red-black tree classique est un BST dans lequel les liens sont colorés soit
rouge soit noir de sorte que tout les chemins de la racine vers un lien null a
le même nombre de liens noirs (équilibre noir parfait) et dans lequel il n'y
a jamais plus d'un lien rouge consécutif le long d'un chemin (mais ceux-ci
peuvent pencher à gauche ou à droite et les deux liens d'un noeud peuvent
être rouges). Dans un red-black BST classique, la hauteur est entre $\sim$ lgN
<<<<<<< HEAD
and $\sim$ 2lgN.\\

{\color{dkgreen}VRAI.}
=======
and $\sim$ 2lgN.
>>>>>>> origin/master
\end{enumerate}
\item Imaginez un algorithme de tri utilisant un BST. Quelle serait la complexité de
votre algorithme si le BST est remplacé par un red-black BST ?


<<<<<<< HEAD
<<<<<<< HEAD
{\color{dkgreen}Pour un arbre non-équilibré, c'est du n\up{2} dans le pire des cas. En moyenne, ce sera du nlog(n). Pour le red/black tree, le pire des cas serait en log(n) $+$ n à cause du parcours infixe.}

=======
>>>>>>> origin/master
=======
>>>>>>> origin/master
\item Est-ce que l’opération de suppression est "commutative" dans le sens que supprimer
x et ensuite directement y d’un BST laisse l’arbre dans même état que si on
avait d’abord supprimé y et puis x ? Donnez un contre exemple ou argumentez
pourquoi c’est effectivement toujours le cas. \\

{\color{dkgreen}Demander les contre-exemples faits au cours}

\item Arbres doublement cousus. Imaginez un algorithme non récursif de parcourt infixe
d’un BST qui n’utilise pas de stack et qui laisse le BST inchangé. Pour se faire, il
faut repenser l’utilisation des liens null dans le BST de cette manière : remplacez
un lien null gauche par un pointeur vers son prédécesseur infixe du noeud
(s’il existe), et remplacez un lien null droit par son successeur infixe. Mettez
à jour put(), deleteMin(), deleteMax() et delete() pour maintenir
ces invariants. Hint : vous pourriez avoir besoin d’ajouter deux boolean’s dans
les noeuds pour indiquer la nature des liens.\\

{\color{dkgreen}Demander les contre-exemples faits au cours}

\end{enumerate}
\end{document}
